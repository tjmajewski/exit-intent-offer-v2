import { authenticate } from "../shopify.server";
import db from "../db.server";
import { getUsageLineItemId, recordUsageCharge, getCommissionRate } from "../utils/billing.server.js";

export const action = async ({ request }) => {
  try {
    const { topic, shop, session, payload } = await authenticate.webhook(request);

    console.log(" Webhook received:", topic);
    console.log("Shop:", shop);
    console.log("Order ID:", payload.id);
    console.log("Order total:", payload.total_price);

    // Check if our discount code was used
    const discountCodes = payload.discount_codes || [];
    const exitDiscountUsed = discountCodes.find(dc => 
      dc.code && /^\d+(OFF|DOLLARSOFF|GIFT)$/i.test(dc.code)
    );

    // EVOLUTION SYSTEM: Track conversion for variant performance
    const exitIntentDiscount = discountCodes.find(dc => 
      dc.code && dc.code.startsWith('EXIT')
    );

    if (exitIntentDiscount) {
      console.log(`[Evolution] Exit intent discount found: ${exitIntentDiscount.code}`);
      
      const shopRecord = await db.shop.findUnique({
        where: { shopifyDomain: shop }
      });

      if (shopRecord) {
        // Find the most recent impression that hasn't been converted yet
        const impression = await db.variantImpression.findFirst({
          where: {
            shopId: shopRecord.id,
            converted: false,
            clicked: true // Only count if they clicked the modal
          },
          orderBy: { timestamp: 'desc' }
        });

        if (impression) {
          const { recordConversion } = await import('../utils/variant-engine.js');
          const revenue = parseFloat(payload.total_price);
          const discountAmount = parseFloat(payload.total_discounts);
          
          await recordConversion(impression.id, revenue, discountAmount);
          
          console.log(`[Evolution] Conversion recorded for impression ${impression.id}`);
          console.log(`[Evolution] Revenue: $${revenue}, Discount: $${discountAmount}`);
        } else {
          console.log('[Evolution] No matching impression found for conversion');
        }
      }
    }

    // PHASE 5: Track ALL discount usage for promotional intelligence
    const shopRecord = await db.shop.findUnique({
      where: { shopifyDomain: shop }
    });

    if (shopRecord && discountCodes.length > 0) {
      for (const dc of discountCodes) {
        if (!dc.code) continue;
        
        // Find promotion in database
        const promo = await db.promotion.findFirst({
          where: {
            shopId: shopRecord.id,
            code: dc.code
          }
        });

        if (promo) {
          // Update usage stats
          const stats = JSON.parse(promo.usageStats);
          stats.total += 1;
          stats.last24h = (stats.last24h || 0) + 1;

          await db.promotion.update({
            where: { id: promo.id },
            data: {
              usageStats: JSON.stringify(stats)
            }
          });

          console.log(` Promotion usage tracked: ${dc.code} (Total: ${stats.total})`);

          // Classify promotion if not yet classified
          if (!promo.classification) {
            await classifyPromotion(promo.id);
          }
        }
      }
    }

    // Check if gift card voucher product is in the order
    const lineItems = payload.line_items || [];
    const giftCardVoucher = lineItems.find(item => 
      item.product_id === 7790476951630
    );

    // If neither discount nor voucher, skip
    // exitDiscountUsed covers legacy codes (e.g. 10OFF, 10DOLLARSOFF)
    // exitIntentDiscount covers EXIT-prefixed codes generated by the app
    if (!exitDiscountUsed && !exitIntentDiscount && !giftCardVoucher) {
      console.log("No exit intent offer used, skipping");
      return new Response(null, { status: 200 });
    }

    // Normalise: treat EXIT-prefixed codes the same as legacy discount codes
    // so that analytics, conversions and billing are recorded for both
    if (!exitDiscountUsed && exitIntentDiscount) {
      exitDiscountUsed = exitIntentDiscount;
    }

    // If gift card voucher found, create real gift card
    if (giftCardVoucher) {
      console.log(" Gift card voucher found in order!");
      
      // Get gift card amount from settings (we'll need to query this)
      const settingsQuery = `
        query {
          shop {
            metafield(namespace: "exit_intent", key: "settings") {
              value
            }
          }
        }
      `;
      
      const { admin } = await authenticate.admin({ session });
      const settingsResponse = await admin.graphql(settingsQuery);
      const settingsResult = await settingsResponse.json();
      const settings = JSON.parse(settingsResult.data.shop?.metafield?.value || '{}');
      
      const giftCardAmount = settings.discountAmount || 15;
      
      // Create real gift card
      console.log(`Creating $${giftCardAmount} gift card for customer...`);
      
      const giftCardMutation = `
        mutation giftCardCreate($input: GiftCardCreateInput!) {
          giftCardCreate(input: $input) {
            giftCard {
              id
              initialValue {
                amount
              }
              maskedCode
            }
            userErrors {
              field
              message
            }
          }
        }
      `;
      
      const giftCardResponse = await admin.graphql(giftCardMutation, {
        variables: {
          input: {
            initialValue: parseFloat(giftCardAmount),
            note: `Exit Intent Offer - Order #${payload.order_number}`,
            customerId: payload.customer?.id ? payload.customer.id.toString().split('/').pop() : null
          }
        }
      });
      
      const giftCardResult = await giftCardResponse.json();
      
      if (giftCardResult.data.giftCardCreate.giftCard) {
        console.log(" Gift card created:", giftCardResult.data.giftCardCreate.giftCard.maskedCode);
      } else {
        console.error("Gift card creation failed:", giftCardResult.data.giftCardCreate.userErrors);
      }
    }

    const orderValue = parseFloat(payload.total_price);
    console.log(` Exit intent discount redeemed: ${exitDiscountUsed.code}`);
    console.log(` Order value: $${orderValue}`);
    
    // Update analytics and modal library
    await updateAnalytics(session, orderValue);
    console.log(" Analytics updated with conversion and revenue");

    // CONVERSIONS TABLE: Store order-level data for reporting
    await storeConversion(shop, payload, exitDiscountUsed, session);
    console.log(" Conversion stored in conversions table");

    // USAGE BILLING: Charge commission on recovered revenue
    await recordUsageBilling(shop, payload, session);

    return new Response(null, { status: 200 });
  } catch (error) {
    console.error("Webhook error:", error);
    return new Response(null, { status: 500 });
  }
};

async function updateAnalytics(session, revenue) {
  // Use the session to make GraphQL requests
  const { admin } = await authenticate.admin({ session });
  
  // Query current analytics and modal library
  const query = `
    query {
      shop {
        id
        analytics: metafield(namespace: "exit_intent", key: "analytics") {
          value
        }
        modalLibrary: metafield(namespace: "exit_intent", key: "modal_library") {
          value
        }
      }
    }
  `;

  const response = await admin.graphql(query);
  const result = await response.json();

  const shopId = result.data.shop.id;

  // Parse current analytics or use defaults
  const currentValue = result.data.shop?.analytics?.value;
  const analytics = currentValue ? JSON.parse(currentValue) : {
    impressions: 0,
    clicks: 0,
    closeouts: 0,
    conversions: 0,
    revenue: 0,
    events: []
  };

  // Increment conversions and add revenue
  analytics.conversions += 1;
  analytics.revenue += revenue;

  // Add timestamped conversion event
  if (!analytics.events) analytics.events = [];
  analytics.events.push({
    type: "conversion",
    timestamp: new Date().toISOString(),
    revenue: revenue
  });

  console.log(" New analytics:", analytics);

  // Save updated analytics
  const analyticsMutation = `
    mutation SetAnalytics($ownerId: ID!, $value: String!) {
      metafieldsSet(metafields: [{
        ownerId: $ownerId
        namespace: "exit_intent"
        key: "analytics"
        value: $value
        type: "json"
      }]) {
        metafields {
          id
        }
        userErrors {
          field
          message
        }
      }
    }
  `;

  await admin.graphql(analyticsMutation, {
    variables: {
      ownerId: shopId,
      value: JSON.stringify(analytics)
    }
  });

  // Update modal library stats
  const modalLibraryValue = result.data.shop?.modalLibrary?.value;
  if (modalLibraryValue) {
    const modalLibrary = JSON.parse(modalLibraryValue);
    const currentModal = modalLibrary.modals?.find(m => m.modalId === modalLibrary.currentModalId);
    
    if (currentModal) {
      currentModal.stats.conversions = (currentModal.stats.conversions || 0) + 1;
      currentModal.stats.revenue = (currentModal.stats.revenue || 0) + revenue;
      
      console.log(` Updated ${currentModal.modalName} stats:`, currentModal.stats);
      
      // Save updated modal library
      const modalLibraryMutation = `
        mutation UpdateModalLibrary($ownerId: ID!, $value: String!) {
          metafieldsSet(metafields: [{
            ownerId: $ownerId
            namespace: "exit_intent"
            key: "modal_library"
            value: $value
            type: "json"
          }]) {
            metafields {
              id
            }
          }
        }
      `;

      await admin.graphql(modalLibraryMutation, {
        variables: {
          ownerId: shopId,
          value: JSON.stringify(modalLibrary)
        }
      });
    }
  }
}

async function classifyPromotion(promoId) {
  const promo = await db.promotion.findUnique({
    where: { id: promoId }
  });

  if (!promo) return;

  const hoursSince = (Date.now() - promo.detectedAt.getTime()) / (1000 * 60 * 60);
  
  // Wait at least 4 hours before classifying
  if (hoursSince < 4) {
    console.log(`⏳ Waiting to classify ${promo.code} (only ${hoursSince.toFixed(1)} hours old)`);
    return;
  }

  const stats = JSON.parse(promo.usageStats);
  const usagePerHour = stats.total / hoursSince;

  let classification, aiStrategy, reason;

  // High usage = site-wide promotion
  if (usagePerHour > 10) {
    classification = "site_wide";
    aiStrategy = promo.amount >= 25 ? "pause" : "decrease";
    reason = `${promo.amount}% site-wide promo detected (${stats.total} uses in ${hoursSince.toFixed(1)} hours)`;
  } 
  // Medium usage = targeted campaign
  else if (usagePerHour > 2) {
    classification = "targeted";
    aiStrategy = "continue";
    reason = `Targeted promo (${usagePerHour.toFixed(1)} uses/hour)`;
  } 
  // Low usage = customer service code
  else {
    classification = "customer_service";
    aiStrategy = "ignore";
    reason = `Low usage - likely customer service code (${stats.total} total uses)`;
  }

  await db.promotion.update({
    where: { id: promo.id },
    data: {
      classification,
      aiStrategy,
      aiStrategyReason: reason,
      status: "active"
    }
  });

  console.log(` Promotion classified: ${promo.code} → ${classification} (${aiStrategy})`);
}

async function storeConversion(shop, orderPayload, discountUsed, session) {
  try {
    // Find shop record
    const shopRecord = await db.shop.findUnique({
      where: { shopifyDomain: shop }
    });

    if (!shopRecord) {
      console.log("Shop not found in database, skipping conversion storage");
      return;
    }

    // Get current modal settings from database (faster and more reliable than GraphQL)
    // We'll use the shopRecord which already has mode, plan, etc.
    // For modal details, we'll fetch from metafields using the existing session
    const { admin } = await authenticate.admin(session);
    
    const settingsQuery = `
      query {
        shop {
          metafield(namespace: "exit_intent", key: "settings") {
            value
          }
          modalLibrary: metafield(namespace: "exit_intent", key: "modal_library") {
            value
          }
        }
      }
    `;
    
    const settingsResponse = await admin.graphql(settingsQuery);
    const settingsResult = await settingsResponse.json();
    const settings = JSON.parse(settingsResult.data.shop?.metafield?.value || '{}');
    const modalLibrary = JSON.parse(settingsResult.data.shop?.modalLibrary?.value || '{"currentModalId":null,"modals":[]}');
    
    // Get current modal info
    const currentModal = modalLibrary.modals?.find(m => m.modalId === modalLibrary.currentModalId);
    
    // Determine if modal had discount enabled
    const modalHadDiscount = settings.discountEnabled === true || settings.discountEnabled === 'true';
    
    // Calculate discount amount (if redeemed)
    const discountAmount = discountUsed ? parseFloat(orderPayload.total_discounts) : 0;
    
    // Store conversion
    await db.conversion.create({
      data: {
        shopId: shopRecord.id,
        orderId: orderPayload.id.toString(),
        orderNumber: orderPayload.order_number.toString(),
        orderValue: parseFloat(orderPayload.total_price),
        customerEmail: orderPayload.customer?.email || orderPayload.email,
        orderedAt: new Date(orderPayload.created_at),
        modalId: modalLibrary.currentModalId || 'unknown',
        modalName: currentModal?.modalName || 'Unknown Modal',
        variantId: null, // Only tracked in AI mode via variant impressions
        modalHadDiscount: modalHadDiscount,
        discountCode: discountUsed?.code || null,
        discountRedeemed: !!discountUsed,
        discountAmount: discountAmount > 0 ? discountAmount : null,
        modalSnapshot: currentModal ? JSON.stringify(currentModal.config) : null
      }
    });

    console.log(` Conversion stored: Order ${orderPayload.order_number} ($${orderPayload.total_price})`);
  } catch (error) {
    console.error("Error storing conversion:", error);
    // Don't throw - we don't want to fail the webhook if conversion storage fails
  }
}

/**
 * Record usage-based billing charge for the recovered order.
 * Commission rates: Starter 5%, Pro 2%, Enterprise 1%
 */
async function recordUsageBilling(shop, orderPayload, session) {
  try {
    // Get shop record with plan info
    const shopRecord = await db.shop.findUnique({
      where: { shopifyDomain: shop }
    });

    if (!shopRecord) {
      console.log("[Billing] Shop not found, skipping usage charge");
      return;
    }

    const tier = shopRecord.plan || "starter";
    const recoveredRevenue = parseFloat(orderPayload.total_price);
    const orderId = orderPayload.id.toString();
    const orderNumber = orderPayload.order_number?.toString();

    // Check if we already recorded a charge for this order (idempotency)
    const existingCharge = await db.usageCharge.findUnique({
      where: { orderId }
    });

    if (existingCharge) {
      console.log(`[Billing] Usage charge already exists for order ${orderId}, skipping`);
      return;
    }

    // Get admin client for API calls
    const { admin } = await authenticate.admin(session);

    // Get the usage line item ID from the active subscription
    const usageInfo = await getUsageLineItemId(admin);

    if (!usageInfo) {
      console.log("[Billing] No active usage subscription found, storing charge as pending");

      // Store as pending - can be charged later or manually
      const commissionRate = getCommissionRate(tier);
      const chargeAmount = Math.round(recoveredRevenue * commissionRate * 100) / 100;

      await db.usageCharge.create({
        data: {
          shopId: shopRecord.id,
          orderId,
          orderNumber,
          recoveredRevenue,
          commissionRate,
          chargeAmount,
          currency: "USD",
          status: "pending",
          planTier: tier,
          conversionAt: new Date(orderPayload.created_at),
          errorMessage: "No active subscription found"
        }
      });
      return;
    }

    // Record the usage charge with Shopify
    const result = await recordUsageCharge(
      admin,
      usageInfo.lineItemId,
      orderId,
      recoveredRevenue,
      tier
    );

    // Store usage charge record in our database
    const commissionRate = getCommissionRate(tier);

    await db.usageCharge.create({
      data: {
        shopId: shopRecord.id,
        orderId,
        orderNumber,
        recoveredRevenue,
        commissionRate,
        chargeAmount: result.chargeAmount,
        currency: "USD",
        status: result.success ? (result.skipped ? "skipped" : "charged") : "failed",
        shopifyChargeId: result.chargeId || null,
        errorMessage: result.error || (result.skipped ? result.reason : null),
        planTier: tier,
        conversionAt: new Date(orderPayload.created_at),
        chargedAt: result.success && !result.skipped ? new Date() : null
      }
    });

    if (result.success) {
      if (result.skipped) {
        console.log(`[Billing] Usage charge skipped for order ${orderId}: ${result.reason}`);
      } else {
        console.log(`[Billing] Usage charge recorded: $${result.chargeAmount} (${(commissionRate * 100).toFixed(0)}% of $${recoveredRevenue})`);
      }
    } else {
      console.error(`[Billing] Usage charge failed for order ${orderId}: ${result.error}`);
    }

  } catch (error) {
    console.error("[Billing] Error recording usage charge:", error);
    // Don't throw - billing failure shouldn't fail the webhook
  }
}